/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */

import { BidiModule, Dir, Direction } from '@angular/cdk/bidi';
import { Component, DebugElement, NgZone, ViewChild } from '@angular/core';
import { ComponentFixture, fakeAsync, flush, TestBed, waitForAsync } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { PRIMARY_OUTLET, provideRouter, Router, RouterOutlet, Routes } from '@angular/router';

import { TriSafeAny } from 'ng-zorro-antd/core/types';
import { provideNzIconsTesting } from 'ng-zorro-antd/icon/testing';

import { TriBreadCrumbItemComponent } from './breadcrumb-item.component';
import { TriBreadCrumbComponent } from './breadcrumb.component';
import { TriBreadCrumbModule } from './breadcrumb.module';
import { TriDemoBreadcrumbBasicComponent } from './demo/basic';
import { TriDemoBreadcrumbDropdownComponent } from './demo/dropdown';
import { TriDemoBreadcrumbSeparatorComponent } from './demo/separator';

describe('breadcrumb', () => {
  describe('basic', () => {
    let fixture: ComponentFixture<TriDemoBreadcrumbBasicComponent>;
    let items: DebugElement[];
    let breadcrumb: DebugElement;

    beforeEach(() => {
      fixture = TestBed.createComponent(TriDemoBreadcrumbBasicComponent);
      items = fixture.debugElement.queryAll(By.directive(TriBreadCrumbItemComponent));
      breadcrumb = fixture.debugElement.query(By.directive(TriBreadCrumbComponent));
    });

    it('should have correct style', () => {
      fixture.detectChanges();
      expect(items.every(item => item.nativeElement.firstElementChild!.classList.contains('ant-breadcrumb-link'))).toBe(
        true
      );
      expect(items.every(item => item.nativeElement.children[1].classList.contains('ant-breadcrumb-separator'))).toBe(
        true
      );
      expect(breadcrumb.nativeElement.classList.contains('ant-breadcrumb')).toBe(true);
    });
  });

  describe('dropdown', () => {
    let fixture: ComponentFixture<TriDemoBreadcrumbDropdownComponent>;
    let items: DebugElement[];

    beforeEach(() => {
      fixture = TestBed.createComponent(TriDemoBreadcrumbDropdownComponent);
      items = fixture.debugElement.queryAll(By.directive(TriBreadCrumbItemComponent));
    });

    it('should dropdown work', () => {
      fixture.detectChanges();

      const dropdownElement = items[2];
      expect((dropdownElement.nativeElement as HTMLElement).querySelector('.ant-dropdown-trigger')).not.toBe(null);
    });
  });

  describe('separator', () => {
    let fixture: ComponentFixture<TriDemoBreadcrumbSeparatorComponent>;
    let items: DebugElement[];
    let breadcrumbs: DebugElement[];

    beforeEach(waitForAsync(() => {
      TestBed.configureTestingModule({
        providers: [provideNzIconsTesting()]
      });
    }));

    beforeEach(() => {
      fixture = TestBed.createComponent(TriDemoBreadcrumbSeparatorComponent);
      items = fixture.debugElement.queryAll(By.directive(TriBreadCrumbItemComponent));
      breadcrumbs = fixture.debugElement.queryAll(By.directive(TriBreadCrumbComponent));
    });

    it('should nzSeparator work', () => {
      fixture.detectChanges();
      expect(items.every(item => item.nativeElement.firstElementChild!.classList.contains('ant-breadcrumb-link'))).toBe(
        true
      );
      expect(items.every(item => item.nativeElement.children[1].classList.contains('ant-breadcrumb-separator'))).toBe(
        true
      );
      expect(breadcrumbs.every(breadcrumb => breadcrumb.nativeElement.classList.contains('ant-breadcrumb'))).toBe(true);
      expect(items[0].nativeElement.children[1].innerText.indexOf('>') > -1).toBe(true);
      expect(items[3].nativeElement.children[1].firstElementChild!.classList.contains('anticon-arrow-right')).toBe(
        true
      );
    });
  });

  describe('auto generated', () => {
    let fixture: ComponentFixture<TriBreadcrumbAutoGenerateDemoComponent>;
    let router: Router;
    let breadcrumb: DebugElement;

    it('should auto generating work', fakeAsync(() => {
      TestBed.configureTestingModule({
        providers: [provideRouter(routes)]
      });

      fixture = TestBed.createComponent(TriBreadcrumbAutoGenerateDemoComponent);
      breadcrumb = fixture.debugElement.query(By.directive(TriBreadCrumbComponent));

      fixture.ngZone!.run(() => {
        router = TestBed.inject(Router);
        router.initialNavigation();

        // Should generate 2 breadcrumbs when reaching out of the `data` scope.
        router.navigate(['one', 'two', 'three', 'four']);
        flushFixture(fixture);
        expect(breadcrumb.componentInstance.breadcrumbs.length).toBe(2);

        // TODO: pending this test because of Angular's bug: https://github.com/angular/angular/issues/25837
        // const items = fixture.debugElement.queryAll(By.directive(NzBreadCrumbItemComponent));
        // dispatchMouseEvent(items[1].nativeElement.querySelector('a'), 'click');
        // flushFixture(fixture);
        // expect(breadcrumb.componentInstance.breadcrumbs.length).toBe(1);

        // Should generate breadcrumbs correctly.
        router.navigate(['one', 'two', 'three']);
        flushFixture(fixture);
        expect(breadcrumb.componentInstance.breadcrumbs.length).toBe(2);
        router.navigate(['one', 'two']);
        flushFixture(fixture);
        expect(breadcrumb.componentInstance.breadcrumbs.length).toBe(1);

        // Shouldn't generate breadcrumb at all.
        router.navigate(['one']);
        flushFixture(fixture);
        expect(breadcrumb.componentInstance.breadcrumbs.length).toBe(0);

        router.navigate(['/']);
        flushFixture(fixture);
        router.navigate([{ outlets: { nonPrimary: ['one', 'two'] } }]);
        flushFixture(fixture);
        expect(router.url).toBe('/(nonPrimary:one/two)');
      });
    }));

    it('should route data breadcrumb label work', fakeAsync(() => {
      TestBed.configureTestingModule({
        providers: [provideRouter(customRouteLabelRoutes)]
      });

      fixture = TestBed.createComponent(TriBreadcrumbRouteLabelDemoComponent);
      breadcrumb = fixture.debugElement.query(By.directive(TriBreadCrumbComponent));

      fixture.ngZone!.run(() => {
        router = TestBed.inject(Router);
        router.initialNavigation();

        // Should nzRouteLabel value is 'customBreadcrumb'
        flushFixture(fixture);
        expect(breadcrumb.componentInstance.nzRouteLabel).toBe('customBreadcrumb');

        // Should generate 2 breadcrumbs when reaching out of the `data` scope.
        router.navigate(['one', 'two', 'three', 'four']);
        flushFixture(fixture);
        expect(breadcrumb.componentInstance.breadcrumbs.length).toBe(2);
        expect(breadcrumb.componentInstance.breadcrumbs[0].label).toBe('Layer 2');
        expect(breadcrumb.componentInstance.breadcrumbs[1].label).toBe('Layer 3');
      });
    }));

    it('should [nzRouteLabelFn] work', fakeAsync(() => {
      TestBed.configureTestingModule({
        providers: [provideRouter(customRouteLabelRoutes)]
      });

      fixture = TestBed.createComponent(TriBreadcrumbRouteLabelWithCustomFnDemoComponent);
      breadcrumb = fixture.debugElement.query(By.directive(TriBreadCrumbComponent));

      fixture.ngZone!.run(() => {
        router = TestBed.inject(Router);
        router.initialNavigation();

        // Should nzRouteLabel value is 'customBreadcrumb'
        flushFixture(fixture);
        expect(breadcrumb.componentInstance.nzRouteLabel).toBe('customBreadcrumb');

        // Should generate 2 breadcrumbs when reaching out of the `data` scope.
        router.navigate(['one', 'two', 'three', 'four']);
        flushFixture(fixture);
        expect(breadcrumb.componentInstance.breadcrumbs.length).toBe(2);
        expect(breadcrumb.componentInstance.breadcrumbs[0].label).toBe('Layer 2 Layer 2');
        expect(breadcrumb.componentInstance.breadcrumbs[1].label).toBe('Layer 3 Layer 3');
      });
    }));

    it('should [nzRouteFn] work', fakeAsync(() => {
      TestBed.configureTestingModule({
        providers: [provideRouter(customRouteLabelRoutes)]
      });

      fixture = TestBed.createComponent(TriBreadcrumbRouteWithCustomFnDemoComponent);
      breadcrumb = fixture.debugElement.query(By.directive(TriBreadCrumbComponent));

      fixture.ngZone!.run(() => {
        router = TestBed.inject(Router);
        router.initialNavigation();

        // Breadcrumb should contain added params by nzRouteFn
        router.navigate(['one', 'two']);
        flushFixture(fixture);
        expect(breadcrumb.componentInstance.breadcrumbs[0].url).toContain('active=true');
      });
    }));

    it('should route data breadcrumb navigate work', fakeAsync(() => {
      TestBed.configureTestingModule({
        providers: [provideRouter(customRouteLabelRoutes)]
      });

      fixture = TestBed.createComponent(TriBreadcrumbRouteLabelDemoComponent);
      breadcrumb = fixture.debugElement.query(By.directive(TriBreadCrumbComponent));

      fixture.ngZone!.run(() => {
        router = TestBed.inject(Router);
        router.initialNavigation();

        flushFixture(fixture);
        expect(breadcrumb.componentInstance.nzRouteLabel).toBe('customBreadcrumb');

        router.navigate(['one', 'two', 'three', 'four']);
        flushFixture(fixture);

        fixture.debugElement.query(By.css('a')).nativeElement.click();
        flushFixture(fixture);
        expect(router.url).toBe('/one/two');
      });
    }));

    it('should raise error when RouterModule is not included', fakeAsync(() => {
      expect(() => {
        fixture = TestBed.createComponent(TriBreadcrumbAutoGenerateErrorDemoComponent);
        fixture.detectChanges();
      }).toThrowError();
    }));

    it('should call navigate() within the Angular zone', fakeAsync(() => {
      let navigateHasBeenCalledWithinTheAngularZone = false;

      TestBed.configureTestingModule({
        providers: [provideRouter(customRouteLabelRoutes)]
      });

      fixture = TestBed.createComponent(TriBreadcrumbRouteLabelDemoComponent);
      breadcrumb = fixture.debugElement.query(By.directive(TriBreadCrumbComponent));

      const navigate = breadcrumb.componentInstance.navigate;
      const spy = spyOn(breadcrumb.componentInstance, 'navigate').and.callFake((url: string, event: MouseEvent) => {
        navigateHasBeenCalledWithinTheAngularZone = NgZone.isInAngularZone();
        return navigate.call(breadcrumb.componentInstance, url, event);
      });

      router = TestBed.inject(Router);
      router.initialNavigation();
      flushFixture(fixture);

      router.navigate(['one', 'two']);
      flushFixture(fixture);

      fixture.debugElement.query(By.css('a')).nativeElement.click();
      flushFixture(fixture);

      expect(spy).toHaveBeenCalledTimes(1);
      expect(navigateHasBeenCalledWithinTheAngularZone).toBeTrue();
    }));
  });

  describe('RTL', () => {
    it('should className correct on dir change', () => {
      const fixture = TestBed.createComponent(TriTestBreadcrumbRtlComponent);
      const breadcrumb = fixture.debugElement.query(By.directive(TriBreadCrumbComponent));
      fixture.detectChanges();
      expect(breadcrumb.nativeElement.classList).toContain('ant-breadcrumb-rtl');

      fixture.componentInstance.direction = 'ltr';
      fixture.detectChanges();
      expect(breadcrumb.nativeElement.className).not.toContain('ant-breadcrumb-rtl');
    });
  });
});

// eslint-disable-next-line  @typescript-eslint/no-explicit-any
function flushFixture(fixture: ComponentFixture<any>): void {
  fixture.detectChanges();
  flush();
  fixture.detectChanges();
}

@Component({
  imports: [RouterOutlet, TriBreadCrumbModule],
  selector: '',
  template: `
    <tri-breadcrumb [autoGenerate]="true"></tri-breadcrumb>
    <router-outlet></router-outlet>
    <router-outlet name="nonPrimary"></router-outlet>
  `
})
class TriBreadcrumbAutoGenerateDemoComponent {}

@Component({
  imports: [RouterOutlet, TriBreadCrumbModule],
  template: `
    <tri-breadcrumb [autoGenerate]="true" [routeLabel]="'customBreadcrumb'"></tri-breadcrumb>
    <router-outlet></router-outlet>
  `
})
class TriBreadcrumbRouteLabelDemoComponent {}

@Component({
  imports: [RouterOutlet, TriBreadCrumbModule],
  template: `
    <tri-breadcrumb
      [autoGenerate]="true"
      [routeLabel]="'customBreadcrumb'"
      [routeLabelFn]="labelFn"
    ></tri-breadcrumb>
    <router-outlet></router-outlet>
  `
})
class TriBreadcrumbRouteLabelWithCustomFnDemoComponent {
  labelFn = (label: string): string => (label ? `${label} ${label}` : '');
}

@Component({
  imports: [RouterOutlet, TriBreadCrumbModule],
  template: `
    <tri-breadcrumb [autoGenerate]="true" [routeLabel]="'customBreadcrumb'" [routeFn]="routeFn"></tri-breadcrumb>
    <router-outlet></router-outlet>
  `
})
class TriBreadcrumbRouteWithCustomFnDemoComponent {
  routeFn = (route: string): string => `${route};active=true`;
}

@Component({
  imports: [TriBreadCrumbModule],
  template: '<tri-breadcrumb [autoGenerate]="true"></tri-breadcrumb>'
})
class TriBreadcrumbAutoGenerateErrorDemoComponent {}

@Component({
  template: 'empty'
})
class TriBreadcrumbNullComponent {}

const routes: Routes = [
  {
    path: 'one',
    component: TriBreadcrumbAutoGenerateDemoComponent,
    data: {
      breadcrumb: ''
    },
    children: [
      {
        path: 'two',
        component: TriBreadcrumbNullComponent,
        data: {
          breadcrumb: 'Layer 2'
        },
        children: [
          {
            path: 'three',
            component: TriBreadcrumbNullComponent,
            data: {
              breadcrumb: 'Layer 3'
            },
            children: [
              {
                path: 'four',
                component: TriBreadcrumbNullComponent,
                data: {
                  breadcrumb: ''
                }
              }
            ]
          }
        ]
      }
    ]
  },
  // Should only work for the primary outlet.
  {
    path: 'one',
    outlet: 'nonPrimary',
    component: TriBreadcrumbAutoGenerateDemoComponent,
    data: {
      breadcrumb: ''
    },
    children: [
      {
        path: 'two',
        component: TriBreadcrumbNullComponent,
        data: {
          breadcrumb: 'Layer 2'
        }
      }
    ]
  }
];

const customRouteLabelRoutes: Routes = [
  {
    path: 'one',
    component: TriBreadcrumbRouteLabelDemoComponent,
    data: {
      customBreadcrumb: ''
    },
    children: [
      {
        path: 'two',
        component: TriBreadcrumbNullComponent,
        data: {
          customBreadcrumb: 'Layer 2'
        },
        children: [
          {
            path: 'three',
            component: TriBreadcrumbNullComponent,
            data: {
              customBreadcrumb: 'Layer 3'
            },
            children: [
              {
                path: 'four',
                component: TriBreadcrumbNullComponent,
                data: {
                  customBreadcrumb: ''
                }
              }
            ]
          }
        ]
      }
    ]
  }
];

@Component({
  imports: [BidiModule, TriDemoBreadcrumbBasicComponent],
  template: `
    <div [dir]="direction">
      <tri-demo-breadcrumb-basic></tri-demo-breadcrumb-basic>
    </div>
  `
})
export class TriTestBreadcrumbRtlComponent {
  @ViewChild(Dir) dir!: Dir;
  direction: Direction = 'rtl';
}

describe('breadcrumb', () => {
  let fixture: ComponentFixture<TriBreadCrumbComponent>;
  let component: TriBreadCrumbComponent;

  beforeEach(() => {
    fixture = TestBed.createComponent(TriBreadCrumbComponent);
    component = fixture.componentInstance;
  });

  it('should have correct value for nextUrl', () => {
    spyOn(component, 'nzRouteFn');
    const mockRout = {
      children: [
        {
          outlet: PRIMARY_OUTLET,
          snapshot: {
            url: [],
            data: {
              breadcrumb: 'breadcrumb'
            }
          },
          children: []
        }
      ]
    };

    component['getBreadcrumbs'](mockRout as TriSafeAny, 'mockUrl', []);

    expect(component.routeFn).toHaveBeenCalledWith('mockUrl');
  });
});
